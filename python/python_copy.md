# [Python] 얕은 복사(copy)와 깊은 복사(deep copy)

대입 연산자를 사용해 리스트를 할당하고 값을 바꾸면 값이 따라서 바뀌게 된다.

> = : 대입 연산자는 같은 객체를 참조하게 한다.

## 그럼 list와 정수형과는 왜 다를까?

list(가변 자료형)

```python
arr = ['abc', 'coffee', 'banana', 'coke']
arr2 = arr
arr2[0] = 'apple'

print(arr)	# ['abc', 'coke', 'coffee', 'banana']
print(arr2)	# ['abc', 'coke', 'coffee', 'banana'] 똑같다.
```

정수형(불변 자료형)

```python
a = 5
b = a
a = 2
print(a) # 2
print(b) # 5
```

정수형도 2나 5의 객체의 주소에 할당하는 것이다. 객체 자체를 바꿔버리니 주소가 달라지는 것이다.

리스트도 통째로 변경시키면 두 리스트는 다르다. 그렇지만 객체를 참조하여 변경시키니 리스트의 주소는 변경없이 요소에 대한 주소만 바뀌게 된다.

가변 자료형인 리스트의 객체에 인덱스로 접근하여 값을 바꾸면 주소는 바뀌지 않고 그 값만 바뀌게 된다. 따라서 같은 주소에 연결된 다른 변수들도 함께 바뀌게 되는 것이다. 

## 같은 객체를 참조하지 않도록 하려면?

### 얕은 복사

1. slice 연산자를 활용하면 다른 주소!! list[:]

2. **list를 list로 형변환한다.**

   ```python
   lst = [1, 2, 'a', 'b']
   lst2 = list(lst)
   lst2[0] = 0
   
   print(lst)	# => [1, 2, 'a', 'b']
   print(lst2)	# => [0, 2, 'a', 'b']
   ```


2차원일 때 슬라이싱으로 하면 또 안된다! 겉의 주소만 복사 하는 것이다.

```python
arr = [[1, 2, 3, 4], [2, 3, 4, 5]]
arr2 = arr[:]
arr[1][0] = 0
print(arr)	# => [[1, 2, 3, 4], [0, 3, 4, 5]]
print(arr2)  # => [[1, 2, 3, 4], [0, 3, 4, 5]]	arr2의 값도 함께 바뀐다
```

최 외곽 주소만 복사하지 안의 요소에 대한 주소는 바꾸지 않는다.

---

### deep copy(깊은 복사)

`import copy`

copy.~ 같은 값이지만 참조를 다르게 하려면 deep copy를 한다.

```python
import copy
arr = [[1, 2, 3, 4], [2, 3, 4, 5]]
arr2 = copy.deepcopy(arr)
arr[1][0] = 0
print(arr)	# => [[1, 2, 3, 4], [0, 3, 4, 5]]
print(arr2)	# => [[1, 2, 3, 4], [2, 3, 4, 5]]	arr2의 값은 안 바뀐다.
```

이렇게 해야하는 상황이 거의 없지만 복잡하게 구성하면 생각해둘 필요가 있다.
