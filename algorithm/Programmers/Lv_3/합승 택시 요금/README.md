# [Programmers] Lv 3. í•©ìŠ¹ íƒì‹œ ìš”ê¸ˆ [2021 KAKAO BLIND RECRUITMENT]

## ğŸ“š ë¬¸ì œ : [í•©ìŠ¹ íƒì‹œ ìš”ê¸ˆ](https://school.programmers.co.kr/learn/courses/30/lessons/72413)

## ğŸ“– í’€ì´

ê·¸ë¦¼ë§Œ ë´ë„ **ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜** ë¬¸ì œì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.

ê·¸ëŸ°ë° ë‹¨ìˆœ ë‹¤ìµìŠ¤íŠ¸ë¼ ë¬¸ì œëŠ” ì•„ë‹ˆê³ , ë‘ ì‚¬ëŒì´ Sì—ì„œ í•¨ê»˜ ì¶œë°œí•´ì„œ ì¤‘ê°„ ì–´ëŠ ì§€ì ì—ì„œ ê°ˆë¼ì§„ í›„ A, B ê°ê°ì— ë„ë‹¬í–ˆì„ ë•Œ ìµœì†Œì˜ ë¹„ìš©ì´ ë“¤ ë•Œë¥¼ ì°¾ëŠ” ë¬¸ì œì´ë‹¤.

ì—¬ê¸°ì„œ ì¤‘ìš”í•œ í¬ì¸íŠ¸ëŠ” ë‹¨ë°©í–¥ì´ ì•„ë‹Œ **ì–‘ë°©í–¥(ë¬´ë°©í–¥) ê·¸ë˜í”„**ë¼ëŠ” ì ì´ë‹¤.

ê²½ìœ í•˜ê²Œ ë˜ëŠ” íŠ¹ì • ì§€ì ì„ Xë¼ê³  í–ˆì„ ë•Œ

S => X, X => A, X => Bì˜ ìµœì†Œ ê°’ì„ êµ¬í•˜ë©´ ëœë‹¤.

ì´ ë•Œ ë‹¨ë°©í–¥ ê·¸ë˜í”„ì¸ ê²½ìš°ëŠ” Sì—ì„œ ëª¨ë“  ì§€ì ì— ë„ë‹¬í•˜ê²Œë˜ëŠ” ê°’ê³¼ ê·¸ ì§€ì  ê°ê°ì—ì„œ ë„ë‹¬í•˜ëŠ” ëª¨ë“  ê°’ë“¤ì„ ì°¾ì•„ì•¼ í•œë‹¤. ì¦‰, ì§€ì ì˜ ê°œìˆ˜ê°€ 100ê°œì´ë©´ 100ë²ˆì˜ ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ êµ¬í•´ ë‹µì„ êµ¬í•´ì•¼í•˜ëŠ” ê²ƒì´ë‹¤.

ê·¸ë ‡ì§€ë§Œ ë¬¸ì œì—ì„œ ì–‘ë°©í–¥ ê·¸ë˜í”„ë¡œ ì£¼ì–´ì¡Œìœ¼ë¯€ë¡œ, ìš°ë¦¬ëŠ” X => Aì™€ A => Xê°€ ê°™ì•„ì§„ë‹¤.

ë”°ë¼ì„œ S => X, A => X, B => Xë¥¼ êµ¬í•˜ë©´ ëœë‹¤.

Xì— ì—¬ëŸ¬ ê°’ì´ ë“¤ì–´ì™€ë„ S, A, Bì—ì„œ ë‹¤ìµìŠ¤íŠ¸ë¼ë§Œ 3ë²ˆ êµ¬í•˜ë©´ ë‹¤ êµ¬í•  ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤.

ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì„ ë¦¬ë·°í•˜ë©´, í™ì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤. í™ì—ëŠ” ê±°ë¦¬ì™€ ì¢Œí‘œ ìˆœìœ¼ë¡œ ë‹´ì•„ ê±°ë¦¬ê°€ ì‘ì€ ê²ƒë¶€í„° í™•ì¸í•œë‹¤. ë‚˜ë¨¸ì§€ëŠ” íë¥¼ ë™ì‘í•˜ë“¯ì´ ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´ ëœë‹¤.

## ğŸ“’ ì½”ë“œ

```python
def solution(n, s, a, b, fares):
    import heapq

    INF = 100000 * 1000
    graph = [[] for _ in range(n + 1)]  # ì—°ê²°ê´€ê³„ í‘œì‹œ
    for x, y, d in fares:               # ì–‘ë°©í–¥ ê·¸ë˜í”„
        graph[x].append([d, y])
        graph[y].append([d, x])
    
    # ë‹¤ìµìŠ¤íŠ¸ë¼
    def dykstra(x, dist_arr):   # xì—ì„œ ëª¨ë“  ì§€ì ê¹Œì§€ ê°€ëŠ” ê²½ìš°
        heap = [[0, x]]         # xê°’ì„ í™ì— ë„£ëŠ”ë‹¤.
        dist_arr[x] = 0         # xëŠ” ìì‹ ì˜ ë…¸ë“œë¡œëŠ” ê±°ë¦¬ê°€ 0
        
        while heap:              # í™ì— ê°’ì´ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ
            d, node = heapq.heappop(heap)
            if dist_arr[node] != d:     # í˜„ì¬ í™ì— ìˆëŠ” ê°’ì´ ìµœì†Œë¡œ ì—…ë°ì´íŠ¸ëœ ê°’ì¸ì§€ í™•ì¸
                continue
            
            for nxt_d, nxt_node in graph[node]:     # ì—°ê²°ëœ ë…¸ë“œë“¤ì„ í™•ì¸í•œë‹¤.
                if dist_arr[nxt_node] > d + nxt_d:      # ìš°íšŒí•˜ëŠ” ê²½ìš°ê°€ ë” ì ì€ ë¹„ìš©ì´ë©´ ë³€ê²½
                    heapq.heappush(heap, [d + nxt_d, nxt_node])
                    dist_arr[nxt_node] = d + nxt_d


    dist_s = [INF for _ in range(n + 1)]    # sì—ì„œ ëª¨ë“  ì§€ì ê¹Œì§€ ë¹„ìš©
    dist_a = [INF for _ in range(n + 1)]    # aì—ì„œ ëª¨ë“  ì§€ì ê¹Œì§€ ë¹„ìš©
    dist_b = [INF for _ in range(n + 1)]    # bì—ì„œ ëª¨ë“  ì§€ì ê¹Œì§€ ë¹„ìš©
    dykstra(s, dist_s)
    dykstra(a, dist_a)
    dykstra(b, dist_b)

    min_cost = INF              # ìµœì†Œ ë¹„ìš©
    # sì—ì„œ ië¡œ iì—ì„œ a, bë¡œì˜ ìµœì†Œ ë¹„ìš©ì˜ í•©ì˜ ìµœì†Œ ê°’ì„ ì°¾ëŠ”ë‹¤.
    # s=> i, i => a, i => b
    for i in range(1, n + 1):
        min_cost = min(min_cost, dist_s[i] + dist_a[i] + dist_b[i])
    
    return min_cost
```

