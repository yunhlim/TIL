# [Baekjoon] 11053. 가장 긴 증가하는 부분 수열 [S2]

## 📚 문제

https://www.acmicpc.net/problem/11053

---

가장 긴 증가하는 부분 수열은 DP Well known 문제이다.

n이 1000이므로 for문을 2번 돌려도 가능하니 완전탐색으로 해결한다.

입력 받은 수열을 첫번째 인덱스부터 확인하며 메모이제이션 배열에 넣어준다.

부분 수열의 최소 길이는 자기 자신인 1이니 1로 메모이제이션을 초기화 한다.

예제로 비교한다.

- Input

> 6
> 10 20 10 30 20 50

먼저 dp를 1로 초기화한다.

| Index | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr   | 10   | 20   | 10   | 30   | 20   | 50   |
| dp    | 1    | 1    | 1    | 1    | 1    | 1    |

Index 1부터 이전의 값이 있으니 Index 1부터 확인한다.

Index 0의 배열 값이 Index 1보다 작으니 Index 0의 dp 값에 1을 더한 값을 넣어준다.

| Index | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr   | 10   | 20   | 10   | 30   | 20   | 50   |
| dp    | 1    | 2    | 1    | 1    | 1    | 1    |

Index 2는 이전의 값 중 더 작은 값이 없으니 dp는 1이다.

| Index | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr   | 10   | 20   | 10   | 30   | 20   | 50   |
| dp    | 1    | 2    | 1    | 1    | 1    | 1    |

Index 3은 이전의 모든 값들이 다 작다. 따라서 dp값이 가장 큰 Index 1의 dp 값인 2에다가 1을 더해 넣어준다.

| Index | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr   | 10   | 20   | 10   | 30   | 20   | 50   |
| dp    | 1    | 2    | 1    | 3    | 1    | 1    |

Index 4보다 작은 Index는 0과 2이다. 따라서 둘다 dp가 1이니 1 더한 2를 넣어준다.

| Index | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr   | 10   | 20   | 10   | 30   | 20   | 50   |
| dp    | 1    | 2    | 1    | 3    | 2    | 1    |

Index 5는 모든 수가 다 작다. 따라서 dp값이 가장 큰 Index 3의 dp 값인 3에다가 1을 더해 넣어준다.

| Index | 0    | 1    | 2    | 3    | 4    | 5    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| arr   | 10   | 20   | 10   | 30   | 20   | 50   |
| dp    | 1    | 2    | 1    | 3    | 2    | 4    |

다음 dp 값들 중 최댓값을 출력한다.

## 📒 코드

```python
n = int(input())
arr = list(map(int, input().split()))
dp = [1 for _ in range(n)]

for i in range(n):
    for j in range(i):
        if arr[i] > arr[j]:
            dp[i] = max(dp[i], 1 + dp[j])
            
print(max(dp))
```

## 🔍 결과

![image-20220316004748901](README.assets/image-20220316004748901.png)